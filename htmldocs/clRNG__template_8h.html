<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>clRNG: clRNG_template.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">clRNG
   </div>
   <div id="projectbrief">An OpenCL library for random number generators (RNG)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_b0856f6b0d80ccb263b2f415c91f9e17.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a>  </div>
  <div class="headertitle">
<div class="title">clRNG_template.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Template of the specialized interface for specific generators (not to be included as is!)  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="clRNG_8h_source.html">clRNG.h</a>&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
</div>
<p><a href="clRNG__template_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclrngStreamState.html">clrngStreamState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream state [<b>device</b>].  <a href="structclrngStreamState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclrngStream.html">clrngStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream object [<b>device</b>].  <a href="structclrngStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclrngHostStream.html">clrngHostStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Host stream object [<b>device-only</b>].  <a href="structclrngHostStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclrngStreamCreator.html">clrngStreamCreator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream creator object.  <a href="structclrngStreamCreator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Stream Creators</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Functions to create, destroy and modify stream creator objects (factory pattern). </p>
</div></td></tr>
<tr class="memitem:ac9b0d337f840b45653a7565c192667eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclrngStreamCreator.html">clrngStreamCreator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clRNG__template_8h.html#ac9b0d337f840b45653a7565c192667eb">clrngCopyStreamCreator</a> (const <a class="el" href="structclrngStreamCreator.html">clrngStreamCreator</a> *creator, <a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a> *err)</td></tr>
<tr class="memdesc:ac9b0d337f840b45653a7565c192667eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate an existing stream creator object.  <a href="#ac9b0d337f840b45653a7565c192667eb">More...</a><br /></td></tr>
<tr class="separator:ac9b0d337f840b45653a7565c192667eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4eb48938ec3e5f47909acfb82c67db7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clRNG__template_8h.html#ad4eb48938ec3e5f47909acfb82c67db7">clrngDestroyStreamCreator</a> (<a class="el" href="structclrngStreamCreator.html">clrngStreamCreator</a> *creator)</td></tr>
<tr class="memdesc:ad4eb48938ec3e5f47909acfb82c67db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a stream creator object.  <a href="#ad4eb48938ec3e5f47909acfb82c67db7">More...</a><br /></td></tr>
<tr class="separator:ad4eb48938ec3e5f47909acfb82c67db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3c452f457112c76d442b9ea1b8b9e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clRNG__template_8h.html#adf3c452f457112c76d442b9ea1b8b9e0">clrngRewindStreamCreator</a> (<a class="el" href="structclrngStreamCreator.html">clrngStreamCreator</a> *creator)</td></tr>
<tr class="memdesc:adf3c452f457112c76d442b9ea1b8b9e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset a stream creator to its original initial state.  <a href="#adf3c452f457112c76d442b9ea1b8b9e0">More...</a><br /></td></tr>
<tr class="separator:adf3c452f457112c76d442b9ea1b8b9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23db82925fbb7ebd496bf1aeda1968f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clRNG__template_8h.html#a23db82925fbb7ebd496bf1aeda1968f6">clrngSetBaseCreatorState</a> (<a class="el" href="structclrngStreamCreator.html">clrngStreamCreator</a> *creator, const <a class="el" href="structclrngStreamState.html">clrngStreamState</a> *baseState)</td></tr>
<tr class="memdesc:a23db82925fbb7ebd496bf1aeda1968f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the base stream state of a stream creator.  <a href="#a23db82925fbb7ebd496bf1aeda1968f6">More...</a><br /></td></tr>
<tr class="separator:a23db82925fbb7ebd496bf1aeda1968f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfbeba8eeef5c6107550b09b87e89e15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clRNG__template_8h.html#acfbeba8eeef5c6107550b09b87e89e15">clrngChangeStreamsSpacing</a> (<a class="el" href="structclrngStreamCreator.html">clrngStreamCreator</a> *creator, cl_int e, cl_int c)</td></tr>
<tr class="memdesc:acfbeba8eeef5c6107550b09b87e89e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the spacing between successive streams.  <a href="#acfbeba8eeef5c6107550b09b87e89e15">More...</a><br /></td></tr>
<tr class="separator:acfbeba8eeef5c6107550b09b87e89e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Stream Allocation, Destruction and Initialization</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Functions to create or destroy random streams and arrays of random streams. </p>
</div></td></tr>
<tr class="memitem:a489c460dc85f7b03d034eec6c4fe9de7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclrngStream.html">clrngStream</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clRNG__template_8h.html#a489c460dc85f7b03d034eec6c4fe9de7">clrngAllocStreams</a> (size_t count, size_t *bufSize, <a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a> *err)</td></tr>
<tr class="memdesc:a489c460dc85f7b03d034eec6c4fe9de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve memory for one or more stream objects.  <a href="#a489c460dc85f7b03d034eec6c4fe9de7">More...</a><br /></td></tr>
<tr class="separator:a489c460dc85f7b03d034eec6c4fe9de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716576f6a8e7fa9c7b366d42f82169d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clRNG__template_8h.html#a716576f6a8e7fa9c7b366d42f82169d4">clrngDestroyStreams</a> (<a class="el" href="structclrngStream.html">clrngStream</a> *streams)</td></tr>
<tr class="memdesc:a716576f6a8e7fa9c7b366d42f82169d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy one or many stream objects.  <a href="#a716576f6a8e7fa9c7b366d42f82169d4">More...</a><br /></td></tr>
<tr class="separator:a716576f6a8e7fa9c7b366d42f82169d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad970b7efe21c1caf1196b8f95d75b994"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclrngStream.html">clrngStream</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clRNG__template_8h.html#ad970b7efe21c1caf1196b8f95d75b994">clrngCreateStreams</a> (<a class="el" href="structclrngStreamCreator.html">clrngStreamCreator</a> *creator, size_t count, size_t *bufSize, <a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a> *err)</td></tr>
<tr class="memdesc:ad970b7efe21c1caf1196b8f95d75b994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory for and create new RNG stream objects.  <a href="#ad970b7efe21c1caf1196b8f95d75b994">More...</a><br /></td></tr>
<tr class="separator:ad970b7efe21c1caf1196b8f95d75b994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b53584bb395ff7b3f584e5204d780af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clRNG__template_8h.html#a6b53584bb395ff7b3f584e5204d780af">clrngCreateOverStreams</a> (<a class="el" href="structclrngStreamCreator.html">clrngStreamCreator</a> *creator, size_t count, <a class="el" href="structclrngStream.html">clrngStream</a> *streams)</td></tr>
<tr class="memdesc:a6b53584bb395ff7b3f584e5204d780af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new RNG stream objects in already allocated memory.  <a href="#a6b53584bb395ff7b3f584e5204d780af">More...</a><br /></td></tr>
<tr class="separator:a6b53584bb395ff7b3f584e5204d780af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4ad622b8226ea4662a7d37d13eeb8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclrngStream.html">clrngStream</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clRNG__template_8h.html#a4f4ad622b8226ea4662a7d37d13eeb8c">clrngCopyStreams</a> (size_t count, const <a class="el" href="structclrngStream.html">clrngStream</a> *streams, <a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a> *err)</td></tr>
<tr class="memdesc:a4f4ad622b8226ea4662a7d37d13eeb8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone RNG stream objects.  <a href="#a4f4ad622b8226ea4662a7d37d13eeb8c">More...</a><br /></td></tr>
<tr class="separator:a4f4ad622b8226ea4662a7d37d13eeb8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab310ec551ce79a40fb8dea4938380043"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clRNG__template_8h.html#ab310ec551ce79a40fb8dea4938380043">clrngCopyOverStreams</a> (size_t count, <a class="el" href="structclrngStream.html">clrngStream</a> *destStreams, const <a class="el" href="structclrngStream.html">clrngStream</a> *srcStreams)</td></tr>
<tr class="memdesc:ab310ec551ce79a40fb8dea4938380043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy RNG stream objects in already allocated memory [<b>device</b>].  <a href="#ab310ec551ce79a40fb8dea4938380043">More...</a><br /></td></tr>
<tr class="separator:ab310ec551ce79a40fb8dea4938380043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e1a89dfba962b8b909812d90e38bdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clRNG__template_8h.html#a10e1a89dfba962b8b909812d90e38bdc">clrngCopyOverStreamsFromGlobal</a> (size_t count, <a class="el" href="structclrngStream.html">clrngStream</a> *destStreams, const <a class="el" href="structclrngHostStream.html">clrngHostStream</a> *srcStreams)</td></tr>
<tr class="memdesc:a10e1a89dfba962b8b909812d90e38bdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy RNG host stream objects from global memory into private memory [<b>device-only</b>].  <a href="#a10e1a89dfba962b8b909812d90e38bdc">More...</a><br /></td></tr>
<tr class="separator:a10e1a89dfba962b8b909812d90e38bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9aff54f5ef9b67840557d7385549e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clRNG__template_8h.html#a2f9aff54f5ef9b67840557d7385549e6">clrngCopyOverStreamsToGlobal</a> (size_t count, <a class="el" href="structclrngHostStream.html">clrngHostStream</a> *destStreams, const <a class="el" href="structclrngStream.html">clrngStream</a> *srcStreams)</td></tr>
<tr class="memdesc:a2f9aff54f5ef9b67840557d7385549e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy RNG device stream objects from private memory into global memory [<b>device-only</b>].  <a href="#a2f9aff54f5ef9b67840557d7385549e6">More...</a><br /></td></tr>
<tr class="separator:a2f9aff54f5ef9b67840557d7385549e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Stream Output</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Functions to read successive values from a random stream. </p>
</div></td></tr>
<tr class="memitem:a4ea5afa78b8db03bf92e2e78a4d30c64"><td class="memItemLeft" align="right" valign="top">cl_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clRNG__template_8h.html#a4ea5afa78b8db03bf92e2e78a4d30c64">clrngRandomU01</a> (<a class="el" href="structclrngStream.html">clrngStream</a> *stream)</td></tr>
<tr class="memdesc:a4ea5afa78b8db03bf92e2e78a4d30c64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the next random value in (0,1) [<b>device</b>].  <a href="#a4ea5afa78b8db03bf92e2e78a4d30c64">More...</a><br /></td></tr>
<tr class="separator:a4ea5afa78b8db03bf92e2e78a4d30c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652e3e4383e0a405dfb82faf9aa5f66c"><td class="memItemLeft" align="right" valign="top">cl_int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clRNG__template_8h.html#a652e3e4383e0a405dfb82faf9aa5f66c">clrngRandomInteger</a> (<a class="el" href="structclrngStream.html">clrngStream</a> *stream, cl_int i, cl_int j)</td></tr>
<tr class="memdesc:a652e3e4383e0a405dfb82faf9aa5f66c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the next random integer value [<b>device</b>].  <a href="#a652e3e4383e0a405dfb82faf9aa5f66c">More...</a><br /></td></tr>
<tr class="separator:a652e3e4383e0a405dfb82faf9aa5f66c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a207d8d64fe104aa60f368e3cfd816f9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clRNG__template_8h.html#a207d8d64fe104aa60f368e3cfd816f9a">clrngRandomU01Array</a> (<a class="el" href="structclrngStream.html">clrngStream</a> *stream, size_t count, cl_double *buffer)</td></tr>
<tr class="memdesc:a207d8d64fe104aa60f368e3cfd816f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill an array with successive random values in (0,1) [<b>device</b>].  <a href="#a207d8d64fe104aa60f368e3cfd816f9a">More...</a><br /></td></tr>
<tr class="separator:a207d8d64fe104aa60f368e3cfd816f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cfe7409bc560b79726502230f005103"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clRNG__template_8h.html#a1cfe7409bc560b79726502230f005103">clrngRandomIntegerArray</a> (<a class="el" href="structclrngStream.html">clrngStream</a> *stream, cl_int i, cl_int j, size_t count, cl_int *buffer)</td></tr>
<tr class="memdesc:a1cfe7409bc560b79726502230f005103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill an array with successive random integer values [<b>device</b>].  <a href="#a1cfe7409bc560b79726502230f005103">More...</a><br /></td></tr>
<tr class="separator:a1cfe7409bc560b79726502230f005103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Stream Navigation</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Functions to roll back or advance streams by many steps. </p>
</div></td></tr>
<tr class="memitem:aeed585f8a960f5d04446ea685bdaaff7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clRNG__template_8h.html#aeed585f8a960f5d04446ea685bdaaff7">clrngRewindStreams</a> (size_t count, <a class="el" href="structclrngStream.html">clrngStream</a> *streams)</td></tr>
<tr class="memdesc:aeed585f8a960f5d04446ea685bdaaff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinitialize streams to their initial states [<b>device</b>].  <a href="#aeed585f8a960f5d04446ea685bdaaff7">More...</a><br /></td></tr>
<tr class="separator:aeed585f8a960f5d04446ea685bdaaff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbad9932bf60f57b31075a53349672af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clRNG__template_8h.html#afbad9932bf60f57b31075a53349672af">clrngRewindSubstreams</a> (size_t count, <a class="el" href="structclrngStream.html">clrngStream</a> *streams)</td></tr>
<tr class="memdesc:afbad9932bf60f57b31075a53349672af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinitialize streams to their initial substream states [<b>device</b>].  <a href="#afbad9932bf60f57b31075a53349672af">More...</a><br /></td></tr>
<tr class="separator:afbad9932bf60f57b31075a53349672af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1494fea0795ee8fc6dd48e1ae8657df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clRNG__template_8h.html#ad1494fea0795ee8fc6dd48e1ae8657df">clrngForwardToNextSubstreams</a> (size_t count, <a class="el" href="structclrngStream.html">clrngStream</a> *streams)</td></tr>
<tr class="memdesc:ad1494fea0795ee8fc6dd48e1ae8657df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance streams to the next substreams [<b>device</b>].  <a href="#ad1494fea0795ee8fc6dd48e1ae8657df">More...</a><br /></td></tr>
<tr class="separator:ad1494fea0795ee8fc6dd48e1ae8657df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1725a58bcb9cd34e15b2010d01fa2ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclrngStream.html">clrngStream</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clRNG__template_8h.html#af1725a58bcb9cd34e15b2010d01fa2ce">clrngMakeSubstreams</a> (<a class="el" href="structclrngStream.html">clrngStream</a> *stream, size_t count, size_t *bufSize, <a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a> *err)</td></tr>
<tr class="memdesc:af1725a58bcb9cd34e15b2010d01fa2ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and make an array of substreams of a stream.  <a href="#af1725a58bcb9cd34e15b2010d01fa2ce">More...</a><br /></td></tr>
<tr class="separator:af1725a58bcb9cd34e15b2010d01fa2ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d8bddaea2640d78aff20428ebed195"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clRNG__template_8h.html#ad5d8bddaea2640d78aff20428ebed195">clrngMakeOverSubstreams</a> (<a class="el" href="structclrngStream.html">clrngStream</a> *stream, size_t count, <a class="el" href="structclrngStream.html">clrngStream</a> *substreams)</td></tr>
<tr class="memdesc:ad5d8bddaea2640d78aff20428ebed195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an array of substreams of a stream.  <a href="#ad5d8bddaea2640d78aff20428ebed195">More...</a><br /></td></tr>
<tr class="separator:ad5d8bddaea2640d78aff20428ebed195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6a402984c7edcc355d6e5a1131d533"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clRNG__template_8h.html#a8a6a402984c7edcc355d6e5a1131d533">clrngAdvanceStreams</a> (size_t count, <a class="el" href="structclrngStream.html">clrngStream</a> *streams, cl_int e, cl_int c)</td></tr>
<tr class="memdesc:a8a6a402984c7edcc355d6e5a1131d533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance the state of streams by many steps.  <a href="#a8a6a402984c7edcc355d6e5a1131d533">More...</a><br /></td></tr>
<tr class="separator:a8a6a402984c7edcc355d6e5a1131d533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Work Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Functions to submit work-items to command queues. </p>
</div></td></tr>
<tr class="memitem:adfacfd6ad077cc83c2b46815b937d549"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clRNG__template_8h.html#adfacfd6ad077cc83c2b46815b937d549">clrngDeviceRandomU01Array</a> (size_t streamCount, cl_mem streams, size_t numberCount, cl_mem outBuffer, cl_uint numQueuesAndEvents, cl_command_queue *commQueues, cl_uint numWaitEvents, const cl_event *waitEvents, cl_event *outEvents)</td></tr>
<tr class="memdesc:adfacfd6ad077cc83c2b46815b937d549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a buffer of random numbers.  <a href="#adfacfd6ad077cc83c2b46815b937d549">More...</a><br /></td></tr>
<tr class="separator:adfacfd6ad077cc83c2b46815b937d549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Miscellaneous Functions</div></td></tr>
<tr class="memitem:a4d32160c8394ddf98cc99bab156178da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clRNG__template_8h.html#a4d32160c8394ddf98cc99bab156178da">clrngWriteStreamInfo</a> (const <a class="el" href="structclrngStream.html">clrngStream</a> *stream, FILE *file)</td></tr>
<tr class="memdesc:a4d32160c8394ddf98cc99bab156178da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format and output information about a stream object to a file.  <a href="#a4d32160c8394ddf98cc99bab156178da">More...</a><br /></td></tr>
<tr class="separator:a4d32160c8394ddf98cc99bab156178da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Template of the specialized interface for specific generators (not to be included as is!) </p>
<p>The function and type names in this API all start with <code>clrng</code>. In each specific implementation, this prefix is expanded to a specific prefix; e.g., <code>clrngMrg31k3p</code> for the MRG31k3p generator.</p>
<p>In the standard case, streams and substreams are defined as in <a class="el" href="citelist.html#CITEREF_iLEC08j">[10]</a>, <a class="el" href="citelist.html#CITEREF_rLEC91a">[2]</a>, <a class="el" href="citelist.html#CITEREF_rLEC02a">[5]</a> . The sequence of successive states of the base RNG over its entire period of length \(\rho\) is divided into streams whose starting points are \(Z\) steps apart. The sequence for each stream (of length \(Z\)) is further divided into substreams of length \(W\). The integers \(Z\) and \(W\) have default values that have been carefully selected to avoid detectable dependence between successive streams and substreams, and are large enough to make sure that streams and substreams will not be exhausted in practice. It is strongly recommended to never change these values (even if the software allows it). The initial state of the first stream (the seed of the library) has a default value. It can be changed by invoking <a class="el" href="clRNG__template_8h.html#a23db82925fbb7ebd496bf1aeda1968f6" title="Change the base stream state of a stream creator. ">clrngSetBaseCreatorState()</a> before creating a first stream.</p>
<p>A stream object is a structure that contains the current state of the stream, its initial state (at the beginning of the stream), and the initial state of the current substream. Whenever the user creates a new stream, the software automatically jumps ahead by \(Z\) steps to find its initial state, and the three states in the stream object are set to it. The form of the state depends on the type of RNG.</p>
<p>Some functions are available on both the host and the devices (they can be used within a kernel) whereas others (such as stream creation) are available only on the host. Many functions are defined only for arrays of streams; for a single stream, it suffices to specify an array of size 1.</p>
<p>When a kernel is called, one should pass a copy of the streams from the host to the global memory of the device. Another copy of the stream state must be stored in the private memory of the work item that uses it in the kernel code to generate random numbers. In the current implementation, to avoid wasting (scarce) private memory, without the option <code>CLRNG_ENABLE_SUBSTREAMS</code> (see below), only the current state of the stream is stored explicitly in the work-item's private memory. The work item also keeps in private memory a pointer to the initial state of the stream, but this initial state is not copied into private memory, and the work item does not keep track of the initial state of the current substream. With the option <code>CLRNG_ENABLE_SUBSTREAMS</code>, the initial state of the current substream is also stored into private memory. This permits one to rewind the current state to it or move forward to the next substream.</p>
<p>To use the clRNG library from within a user-defined kernel, the user must include the clRNG header file corresponding to the desired RNG via an <code>include</code> directive. Other specific preprocessor macros can be placed <em>before</em> including the header file to change settings of the library when the default values are not suitable for the user. The following options are currently available:</p>
<ul>
<li><code>CLRNG_SINGLE_PRECISION:</code> With this option, all the random numbers returned by <a class="el" href="clRNG__template_8h.html#a4ea5afa78b8db03bf92e2e78a4d30c64" title="Generate the next random value in (0,1) [device]. ">clrngRandomU01()</a> and <a class="el" href="clRNG__template_8h.html#a207d8d64fe104aa60f368e3cfd816f9a" title="Fill an array with successive random values in (0,1) [device]. ">clrngRandomU01Array()</a>, and generated by <a class="el" href="clRNG__template_8h.html#adfacfd6ad077cc83c2b46815b937d549" title="Fill a buffer of random numbers. ">clrngDeviceRandomU01Array()</a>, will be of type <code>cl_float</code> instead of <code>cl_double</code> (the default setting). This option can be activated on the device and the host separately (i.e., on either one or on both), and affects all implemented RNGs.</li>
<li><code>CLRNG_ENABLE_SUBSTREAMS:</code> With this option, the current state of a stream can be reset on the device to the initial state of the current or next substream. This is made possible by storing in private memory the initial substream state. Without this option, by default, this is not possible and only the current state of the stream and a pointer to its initial state (left in global memory) are kept in private memory and is accessible, in a work item. <b>This option applies only to the device; operations on substreams are always available on the host.</b></li>
</ul>
<p>For example, to enable substreams support, generate single-precision floating point numbers on the device, and use the MRG31k3p generator, one would have, in the device code: </p><div class="fragment"><div class="line"><span class="preprocessor">#define  CLRNG_ENABLE_SUBSTREAMS</span></div>
<div class="line"><span class="preprocessor">#define  CLRNG_SINGLE_PRECISION</span></div>
<div class="line"><span class="preprocessor">#include &lt;mrg31k3p.clh&gt;</span></div>
</div><!-- fragment --><p>To generate single-precision floating point numbers also on the host, still using the MRG31k3p generator, the host code should contain: </p><div class="fragment"><div class="line"><span class="preprocessor">#define CLRNG_SINGLE_PRECISION</span></div>
<div class="line"><span class="preprocessor">#include &lt;mrg31k3p.h&gt;</span></div>
</div><!-- fragment --><p>The functions described here are all available on the host, in all implementations, unless specified otherwise. Only some of the functions and types are also available on the device in addition to the host; they are tagged with [<b>device</b>]. Other functions are only available on the device; they are tagged with [<b>device-only</b>]. Some functions return an error code in <code>err</code>.</p>
<h1>Implemented RNG's</h1>
<p>The following table lists the RNG's that are currently implemented in clRNG with the name of the corresponding header file.</p>
<table class="doxtable">
<tr>
<th>RNG </th><th>Prefix </th><th>Host Header File </th><th>Device Header File  </th></tr>
<tr>
<td>MRG31k3p </td><td><code>Mrg31k3p</code> </td><td>mrg31k3p.h </td><td>mrg31k3p.clh </td></tr>
<tr>
<td>MRG32k3a </td><td><code>Mrg32k3a</code> </td><td>mrg32k3a.h </td><td>mrg32k3a.clh </td></tr>
<tr>
<td>LFSR113 </td><td><code>Lfsr113</code> </td><td>lfsr113.h </td><td>lfsr113.clh </td></tr>
<tr>
<td>Philox-4×32-10 </td><td><code>Philox432</code> </td><td>philox432.h </td><td>philox432.clh </td></tr>
</table>
<h2>The MRG31k3p Generator</h2>
<p>The MRG31k3p generator is defined in <a class="el" href="citelist.html#CITEREF_rLEC00b">[4]</a> . In its specific implementation, the function and type names start with <code>clrngMrg31k3p</code>. For this RNG, a <em>state</em> is a vector of six 31-bit integers, represented internally as <code>cl_uint</code>. The entire period length of approximately \(2^{185}\) is divided into approximately \(2^{51}\) non-overlapping streams of length \(Z=2^{134}\). Each stream is further partitioned into substreams of length \(W=2^{72}\). The state (and seed) of each stream is a vector of six 31-bit integers. This size of state is appropriate for having streams running in work items on GPU cards, for example, while providing a sufficient period length for most applications.</p>
<h2>The MRG32k3a Generator</h2>
<p>MRG32k3a is a combined multiple recursive generator (MRG) proposed by L'Ecuyer <a class="el" href="citelist.html#CITEREF_rLEC99b">[7]</a> , implemented here in 64-bit integer arithmetic. This RNG has a period length of approximately \(2^{191}\), and is divided into approximately \(2^{64}\) non-overlapping streams of length \(Z = 2^{127}\), and each stream is subdivided in \(2^{51}\) substreams of length \(W = 2^{76}\). These are the same numbers as in <a class="el" href="citelist.html#CITEREF_rLEC02a">[5]</a> . The state of a stream at any given step is a six-dimensional vector of 32-bit integers, but those integers are stored as <code>cl_ulong</code> (64-bit integers) in the present implementation (so they use twice the space). The generator has 32 bits of resolution. Note that in the original version proposed in <a class="el" href="citelist.html#CITEREF_rLEC99b">[7]</a> and <a class="el" href="citelist.html#CITEREF_rLEC02a">[5]</a>, the recurrences are implemented in <code>double</code> instead, and the state is stored in six 32-bit integers. The change in implementation is to avoid using <code>double's</code>, which are not available on many GPU devices, and also because the 64-bit implementation is much faster than that in <code>double</code> when 64-bit integer arithmetic is available on the hardware.</p>
<h2>The LFSR113 Generator</h2>
<p>The LFSR113 generator is defined in <a class="el" href="citelist.html#CITEREF_rLEC99a">[8]</a> . In its implementation, the function and type names start with <code>clrngLfsr113</code>. For this RNG, a <em>state</em> vector of four 31-bit integers, represented internally as <code>cl_uint</code>. The period length of approximately \(2^{113}\) is divided into approximately \(2^{23}\) non-overlapping streams of length \(Z=2^{90}\). Each stream is further partitioned into \(2^{35}\) substreams of length \(W=2^{55}\). Note that the functions <code>clrngLfsr113ChangeStreamsSpacing()</code> and <code>clrngLfsr113AdvancedStreams()</code> are not implemented in the current version.</p>
<h2>The Philox-4×32-10 Generator</h2>
<p>The counter-based Philox-4×32-10 generator is defined in <a class="el" href="citelist.html#CITEREF_rSAL11a">[11]</a> . Unlike the previous three generators, its design is not supported by a theoretical analysis of equidistribution. It has only been subjected to empirical testing with the TestU01 software <a class="el" href="citelist.html#CITEREF_rLEC07b">[3]</a> (the other three generators also have). In its implementation, the function and type names start with <code>clrngPhilox432</code>. For this RNG, a <em>state</em> is a 128-bit counter with a 64-bit key, and a 2-bit index used to iterate over the four 32-bit outputs generated for each counter value. The counter is represented internally as a vector of four 32-bit <code>cl_uint</code> values and the index, as a single <code>cl_uint</code> value. In the current clRNG version, the key is the same for all streams, so it is not stored in each stream object but rather hardcoded in the implementation. The period length of \(2^{130}\) is divided into \(2^{28}\) non-overlapping streams of length \(Z=2^{102}\). Each stream is further partitioned into \(2^{36}\) substreams of length \(W=2^{66}\). The key (all bits to 0), initial counter and order in which the four outputs per counter value are returned are chosen to generate the same values, in the same order, as Random123's <code>Engine</code> module <a class="el" href="citelist.html#CITEREF_rSAL11a">[11]</a>, designed for use with the standard C++11 <code>random</code> library. Note that the function <code>clrngPhilox432ChangeStreamsSpacing()</code> supports only values of \(c\) that are multiples of 4, with either \(e = 0\) or \(e \geq 2\). </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ac9b0d337f840b45653a7565c192667eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclrngStreamCreator.html">clrngStreamCreator</a>* clrngCopyStreamCreator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structclrngStreamCreator.html">clrngStreamCreator</a> *&#160;</td>
          <td class="paramname"><em>creator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicate an existing stream creator object. </p>
<p>Create an identical copy (a clone) of the stream creator <code>creator</code>. To create a copy of the default creator, put <code>NULL</code> as the <code>creator</code> parameter. All the new stream creators returned by <code>clrngCopyStreamCreator(NULL, NULL)</code> will create the same sequence of random streams, unless the default stream creator is used to create streams between successive calls to this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">creator</td><td>Stream creator object to be copied, or <code>NULL</code> to copy the default stream creator. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>Error status variable, or <code>NULL</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created stream creator object. </dd></dl>

</div>
</div>
<a class="anchor" id="ad4eb48938ec3e5f47909acfb82c67db7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a> clrngDestroyStreamCreator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structclrngStreamCreator.html">clrngStreamCreator</a> *&#160;</td>
          <td class="paramname"><em>creator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a stream creator object. </p>
<p>Release the resources associated to a stream creator object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">creator</td><td>Stream creator object to be destroyed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error status </dd></dl>

</div>
</div>
<a class="anchor" id="adf3c452f457112c76d442b9ea1b8b9e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a> clrngRewindStreamCreator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structclrngStreamCreator.html">clrngStreamCreator</a> *&#160;</td>
          <td class="paramname"><em>creator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset a stream creator to its original initial state. </p>
<p>Reset the stream creator to its original initial state, so it can re-create the same streams over again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">creator</td><td>Stream creator object to be reset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error status </dd></dl>

</div>
</div>
<a class="anchor" id="a23db82925fbb7ebd496bf1aeda1968f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a> clrngSetBaseCreatorState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structclrngStreamCreator.html">clrngStreamCreator</a> *&#160;</td>
          <td class="paramname"><em>creator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structclrngStreamState.html">clrngStreamState</a> *&#160;</td>
          <td class="paramname"><em>baseState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the base stream state of a stream creator. </p>
<p>Set the base state of the stream creator, which can be seen as the seed of the underlying RNG. This will be the initial state (or seed) of the first stream created by this creator. Then, for most conventional RNGs, the initial states of successive streams will be spaced equally, by \(Z\) steps in the RNG sequence. The type and size of the <code>baseState</code> parameter depends on the type of RNG. The base state always has a default value, so this function does not need to be invoked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">creator</td><td>Stream creator object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">baseState</td><td>New initial base stream state. Can be set to <code>NULL</code> to use the library default. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error status</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is recommended to use the library default base state. </dd></dl>

</div>
</div>
<a class="anchor" id="acfbeba8eeef5c6107550b09b87e89e15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a> clrngChangeStreamsSpacing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structclrngStreamCreator.html">clrngStreamCreator</a> *&#160;</td>
          <td class="paramname"><em>creator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_int&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_int&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the spacing between successive streams. </p>
<p><b>This function should be used only in exceptional circumstances.</b> It changes the spacing \(Z\) between the initial states of the successive streams from the default value to \(Z = 2^e + c\) if \(e &gt; 0\), or to \(Z = c\) if \(e = 0\). One must have \(e \geq 0\) but \(c\) can take negative values. The default spacing values have been carefully selected for each RNG to avoid overlap and dependence between streams, and it is highly recommended not to change them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">creator</td><td>Stream creator object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>Value of \(e\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Value of \(c\). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error status</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is recommended to use the library default spacing and not to invoke this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a489c460dc85f7b03d034eec6c4fe9de7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclrngStream.html">clrngStream</a>* clrngAllocStreams </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>bufSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reserve memory for one or more stream objects. </p>
<p>Reserve memory space for <code>count</code> stream objects, without creating the stream objects. Returns a pointer to the allocated buffer and returns in <code>bufSize</code> the size of the allocated buffer, in bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of stream objects to allocate. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bufSize</td><td>Size in bytes of the allocated buffer, or <code>NULL</code> if not needed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>Error status variable, or <code>NULL</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the newly allocated buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a716576f6a8e7fa9c7b366d42f82169d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a> clrngDestroyStreams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structclrngStream.html">clrngStream</a> *&#160;</td>
          <td class="paramname"><em>streams</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy one or many stream objects. </p>
<p>Release the memory space taken by those stream objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">streams</td><td>Stream object buffer to be released. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error status </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="MultiStream_2multistream_8c-example.html#a6">MultiStream/multistream.c</a>, and <a class="el" href="RandomArray_2randomarray_8c-example.html#a5">RandomArray/randomarray.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ad970b7efe21c1caf1196b8f95d75b994"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclrngStream.html">clrngStream</a>* clrngCreateStreams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structclrngStreamCreator.html">clrngStreamCreator</a> *&#160;</td>
          <td class="paramname"><em>creator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>bufSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate memory for and create new RNG stream objects. </p>
<p>Create and return an array of <code>count</code> new streams using the specified creator. This function also reserves the memory space required for the structures and initializes the stream states. It returns in <code>bufSize</code> the size of the allocated buffer, in bytes. To use the default creator, put <code>NULL</code> as the <code>creator</code> parameter. To create a single stream, just put set <code>count</code> to 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">creator</td><td>Stream creator object, or <code>NULL</code> to use the default stream creator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Size of the array (use 1 for a single stream object). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bufSize</td><td>Size in bytes of the allocated buffer, or <code>NULL</code> if not needed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>Error status variable, or <code>NULL</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created array of stream object. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="MultiStream_2multistream_8c-example.html#a1">MultiStream/multistream.c</a>, and <a class="el" href="RandomArray_2randomarray_8c-example.html#a2">RandomArray/randomarray.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a6b53584bb395ff7b3f584e5204d780af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a> clrngCreateOverStreams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structclrngStreamCreator.html">clrngStreamCreator</a> *&#160;</td>
          <td class="paramname"><em>creator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structclrngStream.html">clrngStream</a> *&#160;</td>
          <td class="paramname"><em>streams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create new RNG stream objects in already allocated memory. </p>
<p>This function is similar to <code><a class="el" href="clRNG__template_8h.html#ad970b7efe21c1caf1196b8f95d75b994" title="Allocate memory for and create new RNG stream objects. ">clrngCreateStreams()</a></code>, except that it does not reserve memory for the structure. It creates the array of new streams in the preallocated <code>streams</code> buffer, which could have been reserved earlier via either <code><a class="el" href="clRNG__template_8h.html#a489c460dc85f7b03d034eec6c4fe9de7" title="Reserve memory for one or more stream objects. ">clrngAllocStreams()</a></code> or <code><a class="el" href="clRNG__template_8h.html#ad970b7efe21c1caf1196b8f95d75b994" title="Allocate memory for and create new RNG stream objects. ">clrngCreateStreams()</a></code>. It permits the client to reuse memory that was previously allocated for other streams.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">creator</td><td>Stream creator object, or <code>NULL</code> to use the default stream creator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Size of the array (use 1 for a single stream object). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">streams</td><td>Buffer in which the new stream(s) will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error status </dd></dl>

</div>
</div>
<a class="anchor" id="a4f4ad622b8226ea4662a7d37d13eeb8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclrngStream.html">clrngStream</a>* clrngCopyStreams </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structclrngStream.html">clrngStream</a> *&#160;</td>
          <td class="paramname"><em>streams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clone RNG stream objects. </p>
<p>Create an identical copy (a clone) of each of the <code>count</code> stream objects in the array <code>streams</code>. This function allocates memory for all the new structures before cloning, and returns a pointer to the new structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of random number in the array (use 1 for a single stream object). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">streams</td><td>Stream object or array of stream objects to be cloned.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>Error status variable, or <code>NULL</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created stream object or array of stream objects. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="MultiStream_2multistream_8c-example.html#a2">MultiStream/multistream.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ab310ec551ce79a40fb8dea4938380043"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a> clrngCopyOverStreams </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structclrngStream.html">clrngStream</a> *&#160;</td>
          <td class="paramname"><em>destStreams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structclrngStream.html">clrngStream</a> *&#160;</td>
          <td class="paramname"><em>srcStreams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy RNG stream objects in already allocated memory [<b>device</b>]. </p>
<p>Copy (or restore) the stream objects <code>srcStreams</code> into the buffer <code>destStreams</code>, and each of the <code>count</code> stream objects from the array <code>srcStreams</code> into the buffer <code>destStreams</code>. This function <em>does not</em> allocate memory for the structures in <code>destStreams</code>; it assumes that this has already been done. Note: The device API offers variants of this function to convert stream objects across their host and device representations, while copying across different types of memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of stream objects to copy (use 1 for a single stream object). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destStreams</td><td>Destination buffer into which to copy (its content will be overwritten). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcStreams</td><td>Stream object or array of stream objects to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error status</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The device API offers two variants of this function called <a class="el" href="clRNG__template_8h.html#a10e1a89dfba962b8b909812d90e38bdc" title="Copy RNG host stream objects from global memory into private memory [device-only]. ">clrngCopyOverStreamsFromGlobal()</a>, for which <code>srcStreams</code> is a pointer to constant <a class="el" href="structclrngHostStream.html" title="Host stream object [device-only]. ">clrngHostStream</a> objects in global memory, and <a class="el" href="clRNG__template_8h.html#a2f9aff54f5ef9b67840557d7385549e6" title="Copy RNG device stream objects from private memory into global memory [device-only]. ">clrngCopyOverStreamsToGlobal()</a>, for which <code>destStreams</code> is a pointer to (non-constant) <a class="el" href="structclrngHostStream.html" title="Host stream object [device-only]. ">clrngHostStream</a> objects in global memory. </dd></dl>

</div>
</div>
<a class="anchor" id="a10e1a89dfba962b8b909812d90e38bdc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a> clrngCopyOverStreamsFromGlobal </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structclrngStream.html">clrngStream</a> *&#160;</td>
          <td class="paramname"><em>destStreams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structclrngHostStream.html">clrngHostStream</a> *&#160;</td>
          <td class="paramname"><em>srcStreams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy RNG host stream objects from global memory into private memory [<b>device-only</b>]. </p>
<p>Copy the host stream objects <code>srcStreams</code> from global memory as device stream objects into the buffer <code>destStreams</code> in private memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of stream objects to copy (use 1 for a single stream object). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destStreams</td><td>Destination buffer into which to copy (its content will be overwritten). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcStreams</td><td>Host stream object or array of host stream objects to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error status </dd></dl>

</div>
</div>
<a class="anchor" id="a2f9aff54f5ef9b67840557d7385549e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a> clrngCopyOverStreamsToGlobal </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structclrngHostStream.html">clrngHostStream</a> *&#160;</td>
          <td class="paramname"><em>destStreams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structclrngStream.html">clrngStream</a> *&#160;</td>
          <td class="paramname"><em>srcStreams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy RNG device stream objects from private memory into global memory [<b>device-only</b>]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of stream objects to copy (use 1 for a single stream object). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destStreams</td><td>Destination buffer into which to copy (its content will be overwritten). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcStreams</td><td>Device stream object or array of device stream objects to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error status </dd></dl>

</div>
</div>
<a class="anchor" id="a4ea5afa78b8db03bf92e2e78a4d30c64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_double clrngRandomU01 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structclrngStream.html">clrngStream</a> *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the next random value in (0,1) [<b>device</b>]. </p>
<p>Generate and return a (pseudo)random number from the uniform distribution over the interval \((0,1)\), using <code>stream</code>. If this stream is from an RNG, the stream state is advanced by one step before producing the (pseudo)random number.</p>
<p>By default, the returned value is of type <code>cl_double</code>. But if the option <code>CLRNG_SINGLE_PRECISION</code> is defined, the returned value will be of type <code>cl_float</code>. Setting this option changes the type of the returned value for all RNGs and all functions that use <a class="el" href="clRNG__template_8h.html#a4ea5afa78b8db03bf92e2e78a4d30c64" title="Generate the next random value in (0,1) [device]. ">clrngRandomU01()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td>Stream used to generate the random value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A random floating-point value uniformly distributed in \((0,1)\) </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="MultiStream_2multistream_8c-example.html#a9">MultiStream/multistream.c</a>, and <a class="el" href="RandomArray_2randomarray_8c-example.html#a1">RandomArray/randomarray.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a652e3e4383e0a405dfb82faf9aa5f66c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_int clrngRandomInteger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structclrngStream.html">clrngStream</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the next random integer value [<b>device</b>]. </p>
<p>Generate and return a (pseudo)random integer from the discrete uniform distribution over the integers \(\{i, \dots, j \}\), using <code>stream</code>, by calling <a class="el" href="clRNG__template_8h.html#a4ea5afa78b8db03bf92e2e78a4d30c64" title="Generate the next random value in (0,1) [device]. ">clrngRandomU01()</a> once and transforming the output by inversion. That is, it returns <code>i + (cl_int)((j-i+1) * clrngRandomU01(stream))</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td>Stream used to generate the random value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Smallest integer value (inclusive). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>Largest integer value (inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A random integer value uniformly distributed in \(\{i, \dots, j \}\) </dd></dl>

</div>
</div>
<a class="anchor" id="a207d8d64fe104aa60f368e3cfd816f9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a> clrngRandomU01Array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structclrngStream.html">clrngStream</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_double *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill an array with successive random values in (0,1) [<b>device</b>]. </p>
<p>Fill preallocated <code>buffer</code> with <code>count</code> successive (pseudo)random numbers. Equivalent to calling <a class="el" href="clRNG__template_8h.html#a4ea5afa78b8db03bf92e2e78a4d30c64" title="Generate the next random value in (0,1) [device]. ">clrngRandomU01()</a> <code>count</code> times to fill the buffer.</p>
<p>If <code>CLRNG_SINGLE_PRECISION</code> is defined, the buffer argument is of type <code>cl_float</code> and will be filled by <code>count</code> values of type <code>cl_float</code> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td>Stream used to generate the random values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of values in the array. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>Destination buffer (must be pre-allocated). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error status </dd></dl>

</div>
</div>
<a class="anchor" id="a1cfe7409bc560b79726502230f005103"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a> clrngRandomIntegerArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structclrngStream.html">clrngStream</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_int *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill an array with successive random integer values [<b>device</b>]. </p>
<p>Same as <a class="el" href="clRNG__template_8h.html#a207d8d64fe104aa60f368e3cfd816f9a" title="Fill an array with successive random values in (0,1) [device]. ">clrngRandomU01Array()</a>, but for integer values in \(\{i,\dots,j\}\). Equivalent to calling <a class="el" href="clRNG__template_8h.html#a652e3e4383e0a405dfb82faf9aa5f66c" title="Generate the next random integer value [device]. ">clrngRandomInteger()</a> <code>count</code> times to fill the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td>Stream used to generate the random values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Smallest integer value (inclusive). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>Largest integer value (inclusive). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of values in the array. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>Destination buffer (must be pre-allocated). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error status </dd></dl>

</div>
</div>
<a class="anchor" id="aeed585f8a960f5d04446ea685bdaaff7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a> clrngRewindStreams </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structclrngStream.html">clrngStream</a> *&#160;</td>
          <td class="paramname"><em>streams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reinitialize streams to their initial states [<b>device</b>]. </p>
<p>Reinitialize all the streams in <code>streams</code> to their initial states. The current substream also becomes the initial one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of stream objects in the array (use 1 for a single stream object). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">streams</td><td>Stream object or array of stream objects to be reset to the start of the stream(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error status</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function can be slow on the device, because it reads the initial state from global memory. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="MultiStream_2multistream_8c-example.html#a3">MultiStream/multistream.c</a>, and <a class="el" href="RandomArray_2randomarray_8c-example.html#a3">RandomArray/randomarray.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="afbad9932bf60f57b31075a53349672af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a> clrngRewindSubstreams </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structclrngStream.html">clrngStream</a> *&#160;</td>
          <td class="paramname"><em>streams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reinitialize streams to their initial substream states [<b>device</b>]. </p>
<p>Reinitialize all the streams in <code>streams</code> to the initial states of their current substream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of stream objects in the array (use 1 for a single stream object). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">streams</td><td>Stream object or array of stream objects to be reset to the beginning of the current substream(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error status</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is available on the device only if the preprocessor symbol <code>CLRNG_ENABLE_SUBSTREAMS</code> is defined. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="MultiStream_2multistream_8c-example.html#a8">MultiStream/multistream.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ad1494fea0795ee8fc6dd48e1ae8657df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a> clrngForwardToNextSubstreams </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structclrngStream.html">clrngStream</a> *&#160;</td>
          <td class="paramname"><em>streams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advance streams to the next substreams [<b>device</b>]. </p>
<p>Reinitialize all the streams in <code>streams</code> to the initial states of their next substream. The current states and the initial states of the current substreams are changed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of stream objects in the array (use 1 for a single stream object). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">streams</td><td>Stream object or array of stream objects to be advanced to the next substream(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error status</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is available on the device only if the preprocessor symbol CLRNG_ENABLE_SUBSTREAMS is defined. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="MultiStream_2multistream_8c-example.html#a7">MultiStream/multistream.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="af1725a58bcb9cd34e15b2010d01fa2ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclrngStream.html">clrngStream</a>* clrngMakeSubstreams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structclrngStream.html">clrngStream</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>bufSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate and make an array of substreams of a stream. </p>
<p>Make and return an array of <code>count</code> copies of <code>stream</code>, whose current (and initial substream) states are the initial states of <code>count</code> successive substreams of <code>stream</code>. The first substream in the returned array is simply a copy of <code>stream</code>. This function also reserves the memory space required for the structures and initializes the stream states. It returns in <code>bufSize</code> the size of the allocated buffer, in bytes. To create a single stream, just set <code>count</code> to 1. When this function is invoked, the substream state and initial state of <code>stream</code> are advanced by <code>count</code> substreams. </p>

</div>
</div>
<a class="anchor" id="ad5d8bddaea2640d78aff20428ebed195"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a> clrngMakeOverSubstreams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structclrngStream.html">clrngStream</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structclrngStream.html">clrngStream</a> *&#160;</td>
          <td class="paramname"><em>substreams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make an array of substreams of a stream. </p>
<p>This function is similar to clrngMakeStreams(), except that it does not reserve memory for the structure. It creates the array of new streams in the preallocated <code>substreams</code> buffer, which could have been reserved earlier via either <a class="el" href="clRNG__template_8h.html#a489c460dc85f7b03d034eec6c4fe9de7" title="Reserve memory for one or more stream objects. ">clrngAllocStreams()</a>, <a class="el" href="clRNG__template_8h.html#af1725a58bcb9cd34e15b2010d01fa2ce" title="Allocate and make an array of substreams of a stream. ">clrngMakeSubstreams()</a> or <a class="el" href="clRNG__template_8h.html#ad970b7efe21c1caf1196b8f95d75b994" title="Allocate memory for and create new RNG stream objects. ">clrngCreateStreams()</a>. It permits the client to reuse memory that was previously allocated for other streams. </p>

</div>
</div>
<a class="anchor" id="a8a6a402984c7edcc355d6e5a1131d533"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a> clrngAdvanceStreams </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structclrngStream.html">clrngStream</a> *&#160;</td>
          <td class="paramname"><em>streams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_int&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_int&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advance the state of streams by many steps. </p>
<p><b>This function should be used only in very exceptional circumstances.</b> It advances the state of the streams in array <code>streams</code> by \(k\) steps, without modifying the states of other streams, nor the initial stream and substream states for those streams. If \(e &gt; 0\), then \(k = 2^e + c\); if \(e &lt; 0\), then \(k = −2^{|e|} + c\); and if \(e = 0\), then \(k = c\). Note that \(c\) can take negative values. We discourage the use of this procedure to customize the length of streams and substreams. It is better to use the default spacing, which has been carefully selected for each RNG type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of stream objects in the array (use 1 for a single stream object). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">streams</td><td>Stream object or array of stream objects to be advanced. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>Value of \(e\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Value of \(c\). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error status</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Check the implementation for all cases \(e &gt; 0\), \(e = 0\) and \(e &lt; 0\). </dd></dl>

</div>
</div>
<a class="anchor" id="adfacfd6ad077cc83c2b46815b937d549"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a> clrngDeviceRandomU01Array </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>streamCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_mem&#160;</td>
          <td class="paramname"><em>streams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numberCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_mem&#160;</td>
          <td class="paramname"><em>outBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_uint&#160;</td>
          <td class="paramname"><em>numQueuesAndEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_command_queue *&#160;</td>
          <td class="paramname"><em>commQueues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_uint&#160;</td>
          <td class="paramname"><em>numWaitEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cl_event *&#160;</td>
          <td class="paramname"><em>waitEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_event *&#160;</td>
          <td class="paramname"><em>outEvents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill a buffer of random numbers. </p>
<p>Fill the buffer pointed to by <code>outBuffer</code> with <code>numberCount</code> uniform random numbers of type <code>cl_double</code> (or of type <code>cl_float</code> if <code>CLRNG_SINGLE_PRECISION</code> is defined), using <code>streamCount</code> work items. In the current implementation, <code>numberCount</code> must be a multiple of <code>streamCount</code>. See clEnqueueNDRangeKernel() from the OpenCL API documentation for a description of the <code>numWaitEvents</code> and <code>waitEvents</code> arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">streamCount</td><td>Number of streams in <code>stream_array</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">streams</td><td>OpenCL buffer that contains an array of stream objects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numberCount</td><td>Number of random number to store in the buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outBuffer</td><td>OpenCL buffer in which the generated numbers will be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numQueuesAndEvents</td><td>numbers of queues and events (for now only the value 1 is supported) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commQueues</td><td>OpenCL command queue. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numWaitEvents</td><td>Number of events in the event wait list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">waitEvents</td><td>Event wait list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outEvents</td><td>Event object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error status</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function requires access to the clRNG device header files (like <code>mrg31k3p.clh</code>) and assumes that the environment variable <code>CLRNG_ROOT</code> points to the installation path of the clRNG package, where lies the <code>cl/include</code> subdirectory that contains these files. Means of setting an environment variable depend on the operating system used.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Add instructions for OSX, Linux and Windows users on how to set this environment variable.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>In the current implementation, <code>numberCount</code> must be a multiple of <code>streamCount</code>.</dd>
<dd>
In the current implementation, the array <code>streams</code> is left unchanged, as there is no write-back from the device code.</dd>
<dd>
In the current implementation, if the device doesn't support OpenCL 2.0, <code>numberCount</code> must be smaller than or a multiple of the device's maximum workgroup size.</dd>
<dd>
In the current implementation, only <code>numQueuesAndEvents</code> = 1 is supported.</dd></dl>
<p>Assume the variables <code>context</code> and <code>queue</code> are a valid OpenCL context and command queue, and that we want to generate <code>number_count</code> using <code>stream_count</code> distinct streams, where <code>number_count</code> is a multiple of <code>stream_count</code>. To use the <a class="el" href="clRNG__template_8h.html#adfacfd6ad077cc83c2b46815b937d549" title="Fill a buffer of random numbers. ">clrngDeviceRandomU01Array()</a> function, we must first create an array of stream objects: </p><div class="fragment"><div class="line">    <span class="keywordtype">size_t</span> streams_buf_size;</div>
<div class="line">    <a class="code" href="structclrngStream.html">clrngStream</a>* streams = <a class="code" href="clRNG__template_8h.html#ad970b7efe21c1caf1196b8f95d75b994">clrngCreateStreams</a>(NULL, stream_count, &amp;streams_buf_size, (<a class="code" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a> *)&amp;err);</div>
</div><!-- fragment --><p>and create the OpenCL buffers for the stream objects: </p><div class="fragment"><div class="line">    cl_mem streams_buf = clCreateBuffer(context, CL_MEM_HOST_WRITE_ONLY | CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, streams_buf_size, streams, &amp;err);</div>
</div><!-- fragment --><p>and for the generated numbers: </p><div class="fragment"><div class="line">    cl_mem numbers_buf = clCreateBuffer(context, CL_MEM_HOST_READ_ONLY | CL_MEM_WRITE_ONLY, number_count * <span class="keyword">sizeof</span>(fp_type), NULL, &amp;err);</div>
</div><!-- fragment --><p>Next, these can be used to invoke <a class="el" href="clRNG__template_8h.html#adfacfd6ad077cc83c2b46815b937d549" title="Fill a buffer of random numbers. ">clrngDeviceRandomU01Array()</a>: </p><div class="fragment"><div class="line">    cl_event event;</div>
<div class="line">    err = <a class="code" href="clRNG__template_8h.html#adfacfd6ad077cc83c2b46815b937d549">clrngDeviceRandomU01Array</a>(stream_count, streams_buf, number_count, numbers_buf, 1, &amp;queue, 0, NULL, &amp;event);</div>
</div><!-- fragment --><p>At the moment the generated numbers are needed, we must wait for the completion of the generation of the random numbers: </p><div class="fragment"><div class="line">    err = clWaitForEvents(1, &amp;event);</div>
</div><!-- fragment --><p>Then, we can allocate memory for the output numbers and fetch them from the device: </p><div class="fragment"><div class="line">    fp_type* numbers = (fp_type*) malloc(number_count * <span class="keyword">sizeof</span>(fp_type));</div>
<div class="line">    err = clEnqueueReadBuffer(queue, numbers_buf, CL_TRUE, 0, number_count * <span class="keyword">sizeof</span>(fp_type), numbers, 0, NULL, NULL);</div>
</div><!-- fragment --><p>The complete code for this example can be found in RandomArray/randomarray.c. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="RandomArray_2randomarray_8c-example.html#a4">RandomArray/randomarray.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a4d32160c8394ddf98cc99bab156178da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clRNG_8h.html#ae05ea645377d5406587df377625e02ef">clrngStatus</a> clrngWriteStreamInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structclrngStream.html">clrngStream</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format and output information about a stream object to a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>Stream object about which to write information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>File to which to output. Can be set to <code>stdout</code> or <code>stderr</code> for standard output and error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error status </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Mar 23 2015 15:19:55 for clRNG by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
